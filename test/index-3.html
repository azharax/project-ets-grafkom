<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Physics Simulation with Boundary and Trajectory</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #87CEEB; /* Sky blue */
        }
        .controls {
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <div class="controls">
        <label for="forceInput">Force (Use arrow keys): </label>
        <input type="text" id="forceInput" value="0, 0" readonly>
        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        let glCanvas = document.getElementById('glCanvas');
        let gl = glCanvas.getContext('webgl');

        if (!gl) {
            alert("WebGL not supported, falling back on experimental-webgl");
            gl = glCanvas.getContext('experimental-webgl');
        }

        if (!gl) {
            alert("Your browser does not support WebGL");
        }

        // Shader sources
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                gl_PointSize = 10.0;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1, 1, 0, 1);  // Yellow color
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed with: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program failed to link: ' + gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Lookup position attribute location
        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

        // Create buffer and bind it
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Enable the attribute and set how to pull data
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // Ball initial values
        let ball = {
            x: 0,
            y: 0.9,
            radius: 0.05,
            vx: 0,
            vy: 0,
            ax: 0,
            ay: -0.001, // Gravity
            isDragging: false
        };

        const groundY = -0.9;
        const leftX = -1;
        const rightX = 1;
        const topY = 1;
        const friction = 0.00005;
        let isMouseDown = false;
        let startX, startY;
        let force = { x: 0, y: 0 };
        let trajectory = [];
        let running = false;

        // Set up event listeners for user input
        window.addEventListener('keydown', function (e) {
            if (e.key === 'ArrowUp') force.y += 0.001;
            if (e.key === 'ArrowDown') force.y -= 0.001;
            if (e.key === 'ArrowLeft') force.x -= 0.001;
            if (e.key === 'ArrowRight') force.x += 0.001;
            document.getElementById('forceInput').value = `${force.x.toFixed(3)}, ${force.y.toFixed(3)}`;
        });

        document.getElementById('startBtn').addEventListener('click', function () {
            ball.vx = force.x;
            ball.vy = force.y;
            running = true;
            requestAnimationFrame(updateBall);
        });

        document.getElementById('resetBtn').addEventListener('click', function () {
            reset();
        });

        // Clear the canvas
        function clearCanvas() {
            gl.clearColor(0.53, 0.81, 0.98, 1); // Sky blue color
            gl.clear(gl.COLOR_BUFFER_BIT);
        }

        // Draw ball
        function drawBall(x, y) {
            let positions = [x, y];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.drawArrays(gl.POINTS, 0, 1);
        }

        // Draw ground, walls, and ceiling
        function drawBoundaries() {
            const lines = [
                -1, groundY, 1, groundY,    // Ground
                -1, topY, 1, topY,          // Ceiling
                leftX, topY, leftX, groundY,  // Left wall
                rightX, topY, rightX, groundY  // Right wall
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);
            gl.drawArrays(gl.LINES, 0, 8);
        }

        // Draw trajectory
        function drawTrajectory() {
            if (trajectory.length > 0) {
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(trajectory), gl.STATIC_DRAW);
                gl.drawArrays(gl.LINE_STRIP, 0, trajectory.length / 2);
            }
        }

        // Update ball physics
        function updateBall() {
            if (!running) return;

            ball.vx += ball.ax;
            ball.vy += ball.ay;

            ball.x += ball.vx;
            ball.y += ball.vy;

            // Collision with ground, ceiling, left and right walls
            if (ball.y - ball.radius <= groundY) {
                ball.y = groundY + ball.radius;
                ball.vy *= -0.8; // Bounce with reduced velocity
            }
            if (ball.y + ball.radius >= topY) {
                ball.y = topY - ball.radius;
                ball.vy *= -0.8;
            }
            if (ball.x - ball.radius <= leftX) {
                ball.x = leftX + ball.radius;
                ball.vx *= -0.8;
            }
            if (ball.x + ball.radius >= rightX) {
                ball.x = rightX - ball.radius;
                ball.vx *= -0.8;
            }

            // Apply friction
            if (ball.y - ball.radius <= groundY) {
                if (Math.abs(ball.vx) > friction) {
                    ball.vx -= Math.sign(ball.vx) * friction;
                } else {
                    ball.vx = 0;
                }
            }

            // Record trajectory
            trajectory.push(ball.x, ball.y);

            // Clear and redraw
            clearCanvas();
            drawBoundaries();
            drawTrajectory();
            drawBall(ball.x, ball.y);

            requestAnimationFrame(updateBall);
        }

        // Reset simulation
        function reset() {
            ball.x = 0;
            ball.y = 0.9;
            ball.vx = 0;
            ball.vy = 0;
            ball.ax = 0;
            ball.ay = -0.001;
            force.x = 0;
            force.y = 0;
            document.getElementById('forceInput').value = '0, 0';
            trajectory = [];
            running = false;
            clearCanvas();
            drawBoundaries();
            drawBall(ball.x, ball.y);
        }

        // Start the simulation
        reset();
    </script>
</body>
</html>
