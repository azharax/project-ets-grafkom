<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Physics Simulation</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #87CEEB; /* Sky blue */
        }
        .controls {
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <div class="controls">
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        let glCanvas = document.getElementById('glCanvas');
        let gl = glCanvas.getContext('webgl');

        if (!gl) {
            alert("WebGL not supported, falling back on experimental-webgl");
            gl = glCanvas.getContext('experimental-webgl');
        }

        if (!gl) {
            alert("Your browser does not support WebGL");
        }

        // Shader sources
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                gl_PointSize = 10.0;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1, 1, 0, 1);  // Yellow color
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed with: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program failed to link: ' + gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Lookup position attribute location
        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

        // Create buffer and bind it
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Enable the attribute and set how to pull data
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // Ball initial values
        let ball = {
            x: 0,
            y: 0.9,
            radius: 0.05,
            vx: 0,
            vy: 0,
            ax: 0,
            ay: -0.001, // Gravity
            isDragging: false
        };

        const groundY = -0.9;
        const friction = 0.00005;
        let isMouseDown = false;
        let startX, startY;

        // Set up event listeners
        glCanvas.addEventListener('mousedown', function (e) {
            ball.isDragging = true;
            startX = (e.clientX / glCanvas.width) * 2 - 1;
            startY = -((e.clientY / glCanvas.height) * 2 - 1);
            isMouseDown = true;
        });

        glCanvas.addEventListener('mousemove', function (e) {
            if (ball.isDragging && isMouseDown) {
                let endX = (e.clientX / glCanvas.width) * 2 - 1;
                let endY = -((e.clientY / glCanvas.height) * 2 - 1);
                drawTrajectory(startX, startY, endX, endY);
            }
        });

        glCanvas.addEventListener('mouseup', function (e) {
            if (ball.isDragging) {
                let endX = (e.clientX / glCanvas.width) * 2 - 1;
                let endY = -((e.clientY / glCanvas.height) * 2 - 1);
                ball.vx = (endX - startX) * 0.05; // Scaling factor for velocity
                ball.vy = (endY - startY) * 0.05;
                ball.isDragging = false;
            }
            isMouseDown = false;
        });

        document.getElementById('resetBtn').addEventListener('click', function () {
            reset();
        });

        // Clear the canvas
        function clearCanvas() {
            gl.clearColor(0.53, 0.81, 0.98, 1); // Sky blue color
            gl.clear(gl.COLOR_BUFFER_BIT);
        }

        // Draw ball
        function drawBall(x, y) {
            let positions = [x, y];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.drawArrays(gl.POINTS, 0, 1);
        }

        // Draw ground
        function drawGround() {
            const groundLine = [
                -1, groundY,
                1, groundY
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(groundLine), gl.STATIC_DRAW);
            gl.drawArrays(gl.LINES, 0, 2);
        }

        // Draw trajectory
        function drawTrajectory(startX, startY, endX, endY) {
            clearCanvas();
            drawGround();
            const line = [
                startX, startY,
                endX, endY
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(line), gl.STATIC_DRAW);
            gl.drawArrays(gl.LINES, 0, 2);
        }

        // Update ball physics
        function updateBall() {
            ball.vx += ball.ax;
            ball.vy += ball.ay;

            ball.x += ball.vx;
            ball.y += ball.vy;

            // Collision with ground
            if (ball.y - ball.radius <= groundY) {
                ball.y = groundY + ball.radius;
                ball.vy *= -0.8; // Bounce with reduced velocity

                // Apply friction on the ground
                if (Math.abs(ball.vx) > friction) {
                    ball.vx -= Math.sign(ball.vx) * friction;
                } else {
                    ball.vx = 0;
                }
            }

            // Prevent ball from falling through the ground
            if (ball.y < groundY) {
                ball.y = groundY;
                ball.vy = 0;
            }

            // Clear and redraw
            clearCanvas();
            drawGround();
            drawBall(ball.x, ball.y);

            requestAnimationFrame(updateBall);
        }

        // Reset simulation
        function reset() {
            ball.x = 0;
            ball.y = 0.9;
            ball.vx = 0;
            ball.vy = 0;
            ball.ax = 0;
            ball.ay = -0.001;
            clearCanvas();
            drawGround();
            drawBall(ball.x, ball.y);
        }

        // Start the simulation
        reset();
        updateBall();
    </script>
</body>
</html>
